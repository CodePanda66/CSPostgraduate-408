(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{599:function(_,v,t){"use strict";t.r(v);var a=t(4),s=Object(a.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h2",{attrs:{id:"_1、死锁的概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、死锁的概念"}},[_._v("#")]),_._v(" 1、死锁的概念")]),_._v(" "),t("p",[_._v("当多个进程因竞争系统资源或互相通信而处于永久阻塞状态时，若无外力作用，这些进程都将无法向前推进。其中每一个进程都无限期地等待其他进程释放资源，这种状态被称为"),t("strong",[_._v("死锁")]),_._v("。")]),_._v(" "),t("h2",{attrs:{id:"_2、死锁产生的原因和必要条件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、死锁产生的原因和必要条件"}},[_._v("#")]),_._v(" 2、死锁产生的原因和必要条件")]),_._v(" "),t("h3",{attrs:{id:"_2-1、资源分类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1、资源分类"}},[_._v("#")]),_._v(" 2.1、资源分类")]),_._v(" "),t("p",[_._v("系统资源可以分为：")]),_._v(" "),t("ul",[t("li",[_._v("可剥夺资源：虽然资源占有者进程需要使用该资源，但一个进程可以强行该资源从占有的进程剥夺。")]),_._v(" "),t("li",[_._v("不可剥夺资源：除占有者进程不再需要使用该资源而主动释放资源，其他进程不得在占有者使用资源的过程中强行剥夺。")])]),_._v(" "),t("p",[_._v("一个资源是否属于可剥夺资源，完全取决于"),t("strong",[_._v("资源本身的性质")]),_._v("。")]),_._v(" "),t("h3",{attrs:{id:"_2-2、死锁产生的原因"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2、死锁产生的原因"}},[_._v("#")]),_._v(" 2.2、死锁产生的原因")]),_._v(" "),t("p",[_._v("竞争资源可能导致死锁了，但竞争资源并不等于死锁。")]),_._v(" "),t("p",[_._v("系统资源不足是产生死锁的根本原因，而进程推进顺序不当是产生死锁的重要原因。")]),_._v(" "),t("h3",{attrs:{id:"_2-3、死锁产生的必要条件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-3、死锁产生的必要条件"}},[_._v("#")]),_._v(" 2.3、死锁产生的必要条件")]),_._v(" "),t("ul",[t("li",[_._v("互斥条件")]),_._v(" "),t("li",[_._v("不可剥夺")]),_._v(" "),t("li",[_._v("请求与保持（部分分配条件）：每次申请部分资源，且在申请的同时保持已有资源")]),_._v(" "),t("li",[_._v("环路等待：存在一种进程资源的循环等待链")])]),_._v(" "),t("p",[_._v("四个必要条件缺一不可！")]),_._v(" "),t("h2",{attrs:{id:"_3、处理死锁的基本方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、处理死锁的基本方法"}},[_._v("#")]),_._v(" 3、处理死锁的基本方法")]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("鸵鸟算法")]),_._v("：就是不管死锁")]),_._v(" "),t("li",[t("strong",[_._v("预防死锁")]),_._v("：设置某些限制条件去破坏产生死锁的 4 个必要条件中的一个或几个。")]),_._v(" "),t("li",[t("strong",[_._v("避免死锁")]),_._v("：在资源动态分配的过程中，用某种方法防止系统进入不安全状态。")]),_._v(" "),t("li",[t("strong",[_._v("监测及解除死锁")])])]),_._v(" "),t("p",[_._v("死锁预防和死锁避免有什么不同？")]),_._v(" "),t("p",[_._v("死锁预防是添加严格的限制条件破坏死锁放生的条件，对系统并发性有很大的副作用。")]),_._v(" "),t("p",[_._v("死锁避免是通过算法计算，避免资源分配让系统处于不安全状态，对限制条件不严格。系统并发性更好。")]),_._v(" "),t("h2",{attrs:{id:"_4、死锁的预防"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4、死锁的预防"}},[_._v("#")]),_._v(" 4、死锁的预防")]),_._v(" "),t("ol",[t("li",[t("p",[_._v("互斥条件")]),_._v(" "),t("p",[_._v("这会受到资源本身固有属性的限制，不能改变。")])]),_._v(" "),t("li",[t("p",[_._v("不可剥夺")]),_._v(" "),t("p",[_._v("对于已经获得某些资源的进程，新的资源请求不能立即被满足，则必须释放所有已经获得的资源。")]),_._v(" "),t("p",[_._v("但是这样重复申请会增加系统开销，降低系统吞吐量。")])]),_._v(" "),t("li",[t("p",[_._v("请求保持")]),_._v(" "),t("p",[_._v("采用预先静态分配方法，要求进程在运行之前一次性申请所有所需的资源，在资源未满足之前，不投入运行。")]),_._v(" "),t("p",[_._v("这种方法必须实现直到该进程所需的全部资源！")])]),_._v(" "),t("li",[t("p",[_._v("环路等待")]),_._v(" "),t("p",[_._v("采用有序资源分配法，将系统中的所有资源都按类型赋予一个编号，要求每一个进程均严格按编号递增顺序请求资源，同类资源一次请求完。")]),_._v(" "),t("p",[_._v("这种方法中各自资源的编号不易修改，限制了新设备的加入；也会增加程序编写的复杂性；不同作业队对资源使用的顺序不同，会造成资源浪费。")])])]),_._v(" "),t("h2",{attrs:{id:"_5、死锁的避免"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5、死锁的避免"}},[_._v("#")]),_._v(" 5、死锁的避免")]),_._v(" "),t("h3",{attrs:{id:"_5-1、安全状态与不安全状态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-1、安全状态与不安全状态"}},[_._v("#")]),_._v(" 5.1、安全状态与不安全状态")]),_._v(" "),t("p",[_._v("若在某一时刻，系统能按某种顺序来为每一个进程分配其所需的资源，使每个进程都可顺利完成，则称此时系统状态为"),t("strong",[_._v("安全状态")]),_._v("，该序列为"),t("strong",[_._v("安全序列")]),_._v("。若某一时刻不存在这样一个安全序列，则系统状态为"),t("strong",[_._v("不安全状态")]),_._v("。")]),_._v(" "),t("p",[_._v("在某一时刻可以存在多种安全序列！")]),_._v(" "),t("p",[_._v("并非所有不安全状态就是死锁状态，但当系统进入不安全状态后，便可能进入死锁状态。")]),_._v(" "),t("p",[_._v("对系统进行安全性检查是根据进程的最大资源需求而定的，而实际运行过程中进程可能不需要这么多的资源。")]),_._v(" "),t("h3",{attrs:{id:"_5-2-银行家算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-银行家算法"}},[_._v("#")]),_._v(" 5.2 银行家算法")]),_._v(" "),t("p",[_._v("这个概念一般考选择题的计算问题，所以没什么概念性的东西，最好根据具体例题理解计算过程，很简单，就是一个加减法的问题。这里就不列出晦涩的描述语言了！")]),_._v(" "),t("h2",{attrs:{id:"_6、死锁的检测和解除"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6、死锁的检测和解除"}},[_._v("#")]),_._v(" 6、死锁的检测和解除")]),_._v(" "),t("h3",{attrs:{id:"_6-1-死锁的检测"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-死锁的检测"}},[_._v("#")]),_._v(" 6.1 死锁的检测")]),_._v(" "),t("h4",{attrs:{id:"_6-1-1、系统资源分配图"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-1、系统资源分配图"}},[_._v("#")]),_._v(" 6.1.1、系统资源分配图")]),_._v(" "),t("p",[_._v("进程的死锁问题可以用有向图更准确而形象地描述，这种有向图被称为系统资源分配图（SRAG）。")]),_._v(" "),t("p",[_._v("在 SRAG 中，用圆圈代表进程，用方框代表资源，从进程到资源的有向边是申请边，表示进程申请一个资源，从资源到进程的有向边是分配边，表示有一个资源分配了进程 。")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://picbed.kimyang.cn/202108240034150.jpg",alt:""}})]),_._v(" "),t("h4",{attrs:{id:"_6-1-2、系统资源分配图的简化方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-2、系统资源分配图的简化方法"}},[_._v("#")]),_._v(" 6.1.2、系统资源分配图的简化方法")]),_._v(" "),t("ul",[t("li",[_._v("在 SRAG 中找出一个既不阻塞又非孤立的进程节点 P （从进程集合中找到一个存在链接的边，且资源申请数量小于系统已有空闲资源数量的进程），P 进程完成后释放所有资源，消去它所有的申请边和分配边")]),_._v(" "),t("li",[_._v("P 释放资源之后，可以唤醒因等待这些资源而阻塞的进程，在执行前一步消去申请边和分配边")]),_._v(" "),t("li",[_._v("若能消去所有的边，则不会产生死锁，若不能消去所有边，则该图称为不可完全简化图。")])]),_._v(" "),t("p",[t("strong",[_._v("不同的简化顺序将得到相同的不可简化图")]),_._v("！")]),_._v(" "),t("p",[_._v("这方法看起来繁琐，但其内核与银行家算法是一样的，上面写的复杂，实际就是一个加加减减的过程。建议结合实际题目理解！")]),_._v(" "),t("h3",{attrs:{id:"_6-2、死锁检测算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-2、死锁检测算法"}},[_._v("#")]),_._v(" 6.2、死锁检测算法")]),_._v(" "),t("p",[_._v("发现死锁的原理就是考察某一时刻系统状态是否安全，即是否存在一组可以实现的系统状态，能使所有进程都得到它们所申请的资源而运行结束。和银行家算法几乎一致！")]),_._v(" "),t("h3",{attrs:{id:"_6-3、死锁解除"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-3、死锁解除"}},[_._v("#")]),_._v(" 6.3、死锁解除")]),_._v(" "),t("ul",[t("li",[_._v("剥夺资源")]),_._v(" "),t("li",[_._v("撤销进程")]),_._v(" "),t("li",[_._v("进程回退：让一个或多个进程回推到足够回避死锁的地步，进程回退时时自愿放弃自愿而不是被剥夺。要求系统保持进程历史信息，设置还原点。")])]),_._v(" "),t("h2",{attrs:{id:"_7、死锁与饿死"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7、死锁与饿死"}},[_._v("#")]),_._v(" 7、死锁与饿死")]),_._v(" "),t("p",[_._v("当等待时间给进程推进和响应带来明显影响时，则称此时发生了"),t("strong",[_._v("进程饥饿")]),_._v("，当饥饿到一定程度，进程所赋予的任务即使完成也不再具有实际意义的时候，该进程称为饿死。")]),_._v(" "),t("p",[_._v("死锁、饥饿与饿死有什么不同？")]),_._v(" "),t("ul",[t("li",[_._v("进程状态上：死锁进程处于等待状态（阻塞状态）；而饥饿进程处于就绪状态，但却可能被饿死。")]),_._v(" "),t("li",[_._v("死锁进程等待的是永远不会被释放的资源，而饥饿进程等待的是会被释放但不会分配到自己的资源，表现为等待时间没有上限！")]),_._v(" "),t("li",[_._v("死锁一定发生了循环等待，而饿死却不是了。所以资源分配图可以检测死锁，无法检测饿死")]),_._v(" "),t("li",[_._v("死锁一定涉及多个进程，饥饿或饿死可能只有一个！")])])])}),[],!1,null,null,null);v.default=s.exports}}]);